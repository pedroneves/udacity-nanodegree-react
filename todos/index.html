<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Udacity ToDo App</title>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
	<script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
	<script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
	<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
	<script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
	<script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>
</head>
<body>

	<div id="app-root"></div>

	<script>

		// Aux functions
		// Source: https://github.com/udacity/reactnd-redux-todos-goals/blob/707da3250f13adfef00fdbf032a563135cdf939a/index.html#L20
		function generateId () {
			return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
		}

		// Action types
		const ADD_TODO = 'ADD_TODO'
		const REMOVE_TODO = 'REMOVE_TODO'
		const TOGGLE_TODO = 'TOGGLE_TODO'
		const ADD_GOAL = 'ADD_GOAL'
		const REMOVE_GOAL = 'REMOVE_GOAL'
		const RECEIVE_DATA = 'RECEIVE_DATA'

		// Action Creators
		function addToDoAction (todo) {
			return { type: ADD_TODO, todo }
		}

		function removeToDoAction (id) {
			return { type: REMOVE_TODO, id }
		}

		function toggleToDoAction (id) {
			return { type: TOGGLE_TODO, id }
		}

		function addGoalAction (goal) {
			return { type: ADD_GOAL, goal }
		}

		function removeGoalAction (id) {
			return { type: REMOVE_GOAL, id }
		}

		function receiveDataAction (todos, goals) {
			return { type: RECEIVE_DATA, goals, todos };
		}

		// Thunks
		function addToDoThunk (name, cb) {
			return (dispatch) => {
				API.saveTodo(name)
					.then((todo) => {
						dispatch(addToDoAction(todo));
						cb();
					}).catch(() => {
						const error = new Error('Failed to add new To-Do');
						error.name = name;
						cb(error);
					})
			}
		}

		function removeToDoThunk (todo, cb) {
			return dispatch => {
				dispatch(removeToDoAction(todo.id));

				API.deleteTodo(todo.id)
					.then(() => cb())
					.catch(() => {
						dispatch(addToDoAction(todo));
						cb(new Error('An error occurred. Try again.'))
					})
			}
		}

		function toggleToDoThunk (todo, cb) {
			return (dispatch) => {
				dispatch(toggleToDoAction(todo.id));

				API.saveTodoToggle(todo.id)
					.then(() => cb())
					.catch(() => {
						dispatch(toggleToDoAction(todo.id))
						cb(new Error('An error occurred. Try again.'))
					})
			}
		}

		function addGoalThunk (name, cb) {
			return (dispatch) => {
				API.saveGoal(name)
					.then((todo) => {
						dispatch(addGoalAction(todo));
						cb();
					}).catch(() => {
						const error = new Error('Failed to add new Goal');
						error.name = name;
						cb(error);
					})
			}
		}

		function removeGoalThunk (goal, cb) {
			return dispatch => {
				dispatch(removeGoalAction(goal.id));

				API.deleteGoal(goal.id)
					.then(() => cb())
					.catch(() => {
						dispatch(addGoalAction(goal));
						cb(new Error('An error occurred. Try again.'))
					})
			}
		}

		function receiveDataThunk (cb) {
			return dispatch => {
				Promise.all([
					API.fetchTodos(),
					API.fetchGoals()
				]).then(results => {
					const [todos, goals] = results;

					store.dispatch(
						receiveDataAction(todos, goals)
					)
				});
			}
		}

		// Reducers
		function todos (todos=[], action) {
			switch (action.type) {
				case ADD_TODO:
					return todos.concat([action.todo])
				case REMOVE_TODO:
					return todos.filter(todo => todo.id !== action.id)
				case TOGGLE_TODO:
					return todos.map(todo => {
						if (todo.id === action.id) {
							todo = Object.assign({}, todo, { isDone: !todo.isDone })
						}

						return todo
					})
				case RECEIVE_DATA:
					return action.todos.map(todo => ({
							id: todo.id,
							name: todo.name,
							isDone: todo.complete
						})
					);
				default:
					return todos
			}
		}

		function goals (goals=[], action) {
			switch (action.type) {
				case ADD_GOAL:
					return goals.concat([action.goal])
				case REMOVE_GOAL:
					return goals.filter(goal => goal.id !== action.id)
				case RECEIVE_DATA:
					return action.goals;
				default:
					return goals
			}
		}

		function loading (state=true, action) {
			switch (action.type) {
				case RECEIVE_DATA:
					return false;
				default:
					return state;
			}
		}

		// Middlewares
		const alertBitcoin = (store) => (next) => (action) => {
			const shouldVerify = [ADD_TODO, ADD_GOAL].includes(action.type);

			if (shouldVerify) {
				let name = action.todo ? action.todo.name : action.goal.name;

				if (name.toLowerCase().includes('bitcoin')){
					return alert('Check bitcoin.org first')
				}
			}

			next(action)
		}

		const logger = (store) => (next) => (action) => {
			console.group(action.type);

			console.log('Prev state:', store.getState())
			console.log('Action:', action);
			const result = next(action);
			console.log('New state:', store.getState())

			console.groupEnd(action.type);

			return result
		}

		// App
		const store = Redux.createStore(
			Redux.combineReducers({
				goals,
				todos,
				loading
			}),
			Redux.applyMiddleware(
				ReduxThunk.default,
				alertBitcoin,
				logger
			)
		);
	</script>

	<script type="text/babel">
		function ListItem (props) {
			const {value, isDone, onToggleItem, onRemoveItem} = props;

			const style = {
				textDecoration: isDone ? 'line-through' : 'none'
			};

			return (
				<li>
					<span onClick={onToggleItem} style={style}>{value}</span>
					<button onClick={onRemoveItem}>X</button>
				</li>
			);
		}

		function List (props) {
			const {
				items,
				onCompleteItem = () => {},
				onRemoveItem = () => {}
			} = props;

			return (
				<ul>
				{
					items.map(item => (
						<ListItem
							key={item.id}
							value={item.name}
							isDone={item.isDone}
							onToggleItem={() => onCompleteItem(item)}
							onRemoveItem={() => onRemoveItem(item)}
						/>
					))
				}
				</ul>
			);
		}

		class Todos extends React.Component {

			handleAddItem = (event) => {
				event.preventDefault();
				const name = this.todoInput.value;

				this.todoInput.disabled = true;
				this.addTodoBtn.disabled = true;

				this.props.dispatch(
					addToDoThunk(name, (error) => {
						if (error) {
							alert(error.message)
						} else {
							this.todoInput.value = '';
						}
						this.todoInput.disabled = false
						this.addTodoBtn.disabled = false;
					})
				)
			}

			onCompleteTodo = (item) => {
				this.props.dispatch(
					toggleToDoThunk(item, (error) => {
						if(error) { alert(error.message) }
					})
				)
			}

			onRemoveTodo = (item) => {
				this.props.dispatch(
					removeToDoThunk(item, (error) => {
						if(error) { alert(error.message) }
					})
				)
			}

			render () {
				return (
					<div>
						<h1>To-do List</h1>
						<form onSubmit={this.handleAddItem}>
							<input
								type="text"
								placeholder="Add todo"
								ref={(input) => this.todoInput = input}
							/>
							<button
								onClick={this.handleAddItem}
								ref={(addTodoBtn => this.addTodoBtn = addTodoBtn)}
							>
								Add To-Do
							</button>
						</form>

						<List
							items={this.props.todos}
							onCompleteItem={this.onCompleteTodo}
							onRemoveItem={this.onRemoveTodo}
						/>
					</div>
				);
			}
		}

		class Goals extends React.Component {

			handleAddItem = (event) => {
				event.preventDefault()
				const name = this.goalInput.value;

				this.goalInput.disabled = true;
				this.addGoalBtn.disabled = true;

				this.props.dispatch(
					addGoalThunk(name, (error) => {
						if (error) {
							alert(error.message)
						} else {
							this.goalInput.value = '';
						}
						this.goalInput.disabled = false
						this.addGoalBtn.disabled = false;
					})
				)
			}

			onRemoveGoal = (item) => {
				this.props.dispatch(
					removeGoalThunk(item, (error) => {
						if(error) { alert(error.message) }
					})
				)
			}

			render () {
				return (
					<div>
						<h1>Goals List</h1>

						<form onSubmit={this.handleAddItem}>
							<input
								type="text"
								placeholder="Add goal"
								ref={(input) => this.goalInput = input}
							/>
							<button
								onClick={this.handleAddItem}
								ref={(addGoalBtn => this.addGoalBtn = addGoalBtn)}
							>
								Add Goal
							</button>
						</form>

						<List items={this.props.goals} onRemoveItem={this.onRemoveGoal} />
					</div>
				);
			}
		}

		class App extends React.Component {

			componentDidMount () {
				const { dispatch, subscribe } = this.props;

				subscribe(() => {
					this.forceUpdate();
				});

				dispatch(
					receiveDataThunk((error, todos, goals) => {
						if (error) {
							return alert(error.message)
						}
					})
				)
			}

			render() {
				const { loading } = this.props;

				if (loading) {
					return <h3>Loading...</h3>
				}

				return (
					<div>
						<ConnectedTodos />
						<ConnectedGoals />
					</div>
				);
			}
		}

		const Context = React.createContext();

		class Provider extends React.Component {
			render() {
				return (
					<Context.Provider value={store}>
					{
						this.props.children
					}
					</Context.Provider>
				)
			}
		}

		class ConnectedApp extends React.Component {
			render () {
				return (
					<Context.Consumer>
					{(store) => {
						const { loading } = store.getState();
						return (
							<App
								dispatch={store.dispatch}
								subscribe={store.subscribe}
								loading={loading}
							/>
						)
					}}
					</Context.Consumer>
				)
			}
		}

		class ConnectedTodos extends React.Component {
			render () {
				return (
					<Context.Consumer>
					{(store) => {
						const { todos } = store.getState();
						return <Todos todos={todos} dispatch={store.dispatch} />
					}}
					</Context.Consumer>
				)
			}
		}

		class ConnectedGoals extends React.Component {
			render () {
				return (
					<Context.Consumer>
					{(store) => {
						const { goals } = store.getState();
						return <Goals goals={goals} dispatch={store.dispatch} />
					}}
					</Context.Consumer>
				)
			}
		}

		ReactDOM.render(
			<Provider>
				<ConnectedApp />,
			</Provider>,
			document.getElementById('app-root')
		);
	</script>
</body>
</html>